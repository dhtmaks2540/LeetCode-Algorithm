import collections

"""
계단은 1칸이나 2칸을 통해 오를 수 있는데 꼭대기까지 오르는 방법이 몇 가지가 있나

접근방법

현재 문제가 최적 부분 구조인 이유는 현재 위치까지 계단을 오르는 방법은 이전 계단까지의 계단을 오르는 방법
그리고 더 이전까지의 계단을 오르는 방법의 합이 되기에 부분 문제의 답이 현재 문제의 답으로 구성되어서
최적 부분 구조로 분리할 수 있다.

또한 이 문제는 하위 문제의 중복이 발생한다. 예를 들어 3번째 칸까지의 계단에 오르는 방법은 2번째 칸 까지의
계단에 오르는 방법 + 1번째 칸의 계단에 오르는 방법으로 이루어져 있고 4번째 칸까지의 계단에 오르는 방법은
3번째 칸까지의 계단에 오르는 방법 + 2번째 칸까지의 계단에 오르는 방법으로 되어있다.
따라서 하위 문제의 중복이 발생해 이를 기록하는 DP 테이블을 사용하는 다이나믹 프로그래밍 유형의 문제이다. 

책의 팁

새로운 유형의 문제를 피보나치 수열 같은 기존의 유명한 문제와 연결해 풀이하는 방법은
문제 해결에 매우 좋은 방법이다. 뿐만 아니라 면접관에게도 이 문제를 보면서 피보나치 수열을
떠올렸다고 얘기한다면 좋은 평가를 받을 수 있을 것이다.
"""

class Solution:
    dp = collections.defaultdict(int)

    # 다이나믹 프로그래밍을 사용하여 문제 풀이(상향식, 타뷸레이션)
    def climbStairs(self, n: int) -> int:
        # DP 테이블
        dp = [0] * 46 # n의 범위는 1부터 45까지

        # 첫 번째 계단을 오르는 방법은 하나
        dp[1] = 1
        # 두 번째 계단을 오르는 방법은 둘(1 + 1, 2)
        dp[2] = 2

        for i in range(3, n + 1):
            # 점화식(현재까지의 계단을 오르는 방법은 이전 계단에서 한칸 오르기 + 두 번째 전 계단에서 두칸 오르기)
            # 두 번째 전 계단에서 한칸 오르고 또 한칸 오르는 방법은 이미 이전 계단에서 한칸 오르는 방법에
            # 포함되어 있기에 이는 무시한다. 다이나믹 프로그래밍의 특징으로
            # 이전은 이미 계산되었다고 믿고 현재의 계산을 풀이하는 것
            dp[i] = dp[i - 1] + dp[i - 2]

        return dp[n]

    # 다이나믹 프로그래밍으로 풀이(메모이제이션, 하향식)
    def climbStairs(self, n: int) -> int:
        # 한 칸을 오르는 방법은 1, 두 칸을 오르는 방법은 2
        if n <= 2:
            return n

        # 이미 값이 기록되어 있다면 리턴
        if self.dp[n] != 0:
            return self.dp[n]

        # 점화식에 해당
        # 한칸 전에서 한 칸 오르기 + 두 번째 칸 전에서 두 칸 오르기
        self.dp[n] = self.climbStairs(n - 1) + self.climbStairs(n - 2)

        return self.dp[n]

n = 10
solution = Solution()
print(solution.climbStairs(n))