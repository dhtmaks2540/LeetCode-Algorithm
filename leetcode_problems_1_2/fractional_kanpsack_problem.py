"""
접근방법

해당 문제가 왜 다이나믹 프로그래밍일까?

해당 문제는 정해진 용량의 가방에 쪼갤 수 없는 짐을 최대 가치가 되게 채우는 것이 목표이다.
따라서 최적 부분 구조에 해당하는데 최적 부분 구조란 문제의 최적 해결 방법이
부분 문제에 대한 최적 해결 방법으로 구성된는 경우를 의미한다. 이 문제가 최적 부분 구조가
되는 이유는 현재의 용량보다 작은 용량에서의 최적의 값이 현재 용량에 부분 문제이기에(e.g 
만약 아래 cargo에서 4kg의 가방에서는 4kg짜리 물건을 넣는 10달러가 최적의 값일 것이다.
여기에서 용량이 5kg의 가방에서는(현재의 용량) 4kg짜리 물건을 넣었던 10달러(부분 문제) + 
1kg짜리 2달러를 넣는 것(부분 문제)의 합이 된다) 따라서 해당 문제는 최적 부분 구조에 해당한다.

그리고 하위 문제의 정답이 중복되기에(1kg의 배낭에서는 1kg 상품이 최고, 2kg의 배낭에서는 1kg 상품 
두 개가(이전의 1kg 배낭에서의 답 + 새로운 1kg)) 다이나믹 프로그래밍으로 분류 후 문제를 풀이할 수 있는 것이다.
"""

cargo = [
    (4, 12),
    (2, 1),
    (10, 4),
    (1, 1),
    (2, 2),
]

# 다이나믹 프로그래밍 동전 채우기와 비슷한 문제
def zero_one_knapsack(cargo):
    capacity = 15
    pack = []

    # 짐의 최대 개수 + 1 iteration
    for i in range(len(cargo) + 1):
        pack.append([])
        # 배낭의 최대 용량 + 1 iteration
        for c in range(capacity + 1):
            # 짐이 없거나 용량이 0이라면
            if i == 0 or c == 0:
                pack[i].append(0)
            # 현재 화물의 용량이 현재 가방의 용량보다 작거나 같다면
            elif cargo[i - 1][1] <= c:
                # 아래 두 변수중 최댓값 넣기
                pack[i].append(
                    max(
                        # 현재 화물의 금액 + 이전 pack의 리스트에서 현재 용량 - 현재 화물의 무게
                        # 즉, 현재 화물의 금액 = 현재 화물의 넣기전 금액
                        cargo[i - 1][0] + pack[i - 1][c - cargo[i - 1][1]],
                        # 이전 pack의 현재 화물의 용량
                        pack[i - 1][c]
                    )
                )
            # 현재 화물의 용량이 현재 가방의 용량보다 크다면
            # 즉, 새로운 값으로 갱신하지 못한다면 이미 계산된 이전의 최선의 값 가져오기
            else:
                # 이전 pack 리스트의 값 넣기
                pack[i].append(pack[i - 1][c])

    return pack[-1][-1]

print(zero_one_knapsack(cargo))