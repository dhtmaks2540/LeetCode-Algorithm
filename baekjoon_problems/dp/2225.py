"""
https://hongjw1938.tistory.com/63

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하라

중복을 포함하며 답에서 1,000,000,000으로 나눈 나머지를 구하라고 했으므로 굉장히 큰 수가 나오기에
다이나믹 프로그래밍을 활용해서 중복되어 나오는 값들을 저장하는 방식으로 시간복잡도를 줄이려고 접근

DFS 함수를 구현한 후 어떤 값이 중복되는지 파악하던 중 현재까지 숫자의 합과 개수가 중복된다는 것을
파악했다. 이에 따라서 현재의 수가 1일 경우 숫자의 개수가 N개인 값들과 현재의 수가 2일 경우
숫자의 개수가 N개인 값들의 경우의 수를 적어놓고 규칙을 파악해보니 현재 값이 N, 개수가 K라면
점화식이 N - 1을 K로 만드는 경우의 수와 N을 K - 1로 만드는 경우의 수의 합이라는 것이 파악되었다.
따라서 이를 코드로 작성하여 풀이했다.

위의 블로그에는 만약 ? + ? + M = N이라고 한다면 M이 0일 경우 이전까지의 합이 N, 1이라면 N - 1,
2라면 N - 2, 3이라면 N - 3, ..., N이라면 0이라는 의미이다. 즉, (N - M) + M = N, 점화식은 이전까지의
숫자의 합에 N이 될 수 있는 임의의 값을 더한 것과 마찬가지인 것이다. 따라서 이를 식으로 나타낸다면
dp[k][n] = dp[k - 1][0] + dp[k - 1][1] + ... + dp[k - 1][n]에 해당하게 된다. 
이는 시간복잡도가 O(KN^2)에 해당하게 되는데 여기서 조금의 최적화를 더 진행할 수 있다.
만약 dp[2][3]이라고 한다면 이는 dp[1][0] + dp[1][1] + dp[1][2] + dp[1][3]에 해당한다. 그런데
여기서 d[2][2]는 dp[1][0] + dp[1][1] + dp[1][2]이 되므로 dp[2][3] = dp[2][2] + dp[1][3]에
해당한다. 이를 사용해서 최적화를 진행하면 결국 점화식은 dp[k][n] = dp[k - 1][n] + dp[k - 1][n]에 해당한다. 
"""

N, K = map(int, input().split(" "))

# 중복되는 하위값을 저장하기 위한 dp 테이블
# 현재 숫자와 개수에 따른 경우의 수
dp = [[0] * 201 for _ in range(201)]

# 1을 n개의 수로 만드는 경우의 수는 n에 해당
for i in range(1, K + 1):
    dp[1][i] = i

# 숫자 iteration
for i in range(2, N + 1):
    # 개수 iteration 
    for j in range(1, K + 1):
        if j == 1:
            dp[i][j] = 1
        else:
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            
print(dp[N][K] % 1000000000)

# 중복되는 것이 숫자와 개수라는 것을 파악한 DFS 함수
# def dfs(sum_of_num, nums_count):
#     global answer
#     if nums_count > K:
#         return
    
#     if nums_count == K and sum_of_num == N:
#         answer += 1
        
#     for i in range(N + 1):
#         sum_of_num += i
#         nums_count += 1
#         dfs(sum_of_num, nums_count)
#         sum_of_num -= i
#         nums_count -= 1

