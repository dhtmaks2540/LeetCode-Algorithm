"""
가장 긴 감소하는 부분 수열을 구하라

해당 문제는 가장 긴 감소하는 부분 수열을 구하는 문제로 가장 긴 증가하는 부분수열을 푸는 방법의
조건을 약간만 변경해서 풀 수 있다. 우선 조건을 검사해서 맞는 경우 하위 문제의 답이 계속 사용하므로
다이나믹 프로그래밍을 사용하여 풀이할 수 있다. 중복되는 값을 저장하는 리스트는 
감소하는 길이를 저장하기 위한 리스트이다.

i번째 원소에 접근한다고 가정하면 우선 dp 테이블에 자기 자신을 포함시킨다.
그 후 i번째 인덱스 전까지 iterate하며 현재 리스트의 값보다 작은 값들이 있을 때,
해당 테이블의 원소에는 최장 감소 수열의 길이가 저장되어 있으므로 이를 가져와서 풀이하면 되는 것이다.
따라서 점화식은 dp[i] = max(dp[i], dp[j] + 1)과 같은 형식이 된다.

"""

import sys

def solution_dp():
    n = int(sys.stdin.readline())
    array = list(map(int, sys.stdin.readline().split(" ")))
    # 감소하는 길이를 저장하기 위한 리스트
    dp = [0] * (n + 1)

    def lis_dp():
        for i in range(n):
            dp[i] = 1 # 자기 자신을 포함하므로 1로 초기화
            for j in range(i):
                # 현재 내 값이 이전에 온 값보다 작다면 -> 감소하는 수
                if array[i] < array[j]:
                    # 점화식에 해당
                    # 현재 기록된 값 또는 기록된 감소된 수의 개수에 자신을 더하는 값 중 max값
                    dp[i] = max(dp[i], dp[j] + 1)
                    
        print(max(dp))
        
    lis_dp()