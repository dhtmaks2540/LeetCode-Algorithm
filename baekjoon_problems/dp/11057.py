"""
수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하라. 수는 0부터 시작할 수 있다.

글자의 수가 1000 최대 1000까지 주어지므로 완전 탐색, DFS, BFS 등을 사용해서는 시간 복잡도가 무조건 초과
여기서 1의 자리수는 10(0 ~ 10), 2의 자리수는 (11 ~ 19/22 ~ 29/.../99) -> 9,8,7과 같이 중복되는
하위 값들이 나오는 규칙이 있는 것 같다. 따라서 다이나믹 프로그래밍을 통해 값을 기록하는 방식으로
풀 수 있을 것 같다고 생각

위의 규칙을 사용하면 두 번째 자리의 1은 1 ~ 9, 2는 2 ~ 9, 3은 3 ~ 9와 같이 9, 8, 7의 값을 가지는데
이는 이전의 자릿수에 해당 값부터 9까지의 경우의 수의 합에 해당한다. 
쉽게 이야기하자면 두자리 수에서 첫 번째 자리를 1로 고정한다고 치면 두 번째 자리는 1 ~ 9가 나오고,
첫 번째 자리를 2로 고정한다고 치면 두 번째 자리는 2 ~ 8이 나오게 된다. 따라서 
테이블에 해당 자릿수의 1 ~ 9까지 오르막 수를 기록하고 현재 자릿수의 i번째 오르막 수는 이전 자릿수의
i부터 9까지 오르막 수의 합으로 계산하면 이것이 점화식이 된다.
"""

# 숫자의 길이
N = int(input())

# 글자 수, 첫 자리 수를 저장하기 위한 dp 테이블
dp = [[0] * 10 for _ in range(1000 + 1)]

# 1자리 수는 모두 1개씩(0도 포함)
for i in range(10):
    dp[1][i] = 1

# 두 번째 자릿수부터 오르막 수 계산
for i in range(2, 1001):
    for j in range(1, 10):
        dp[i][j] = sum(dp[i - 1][j:10])
        
answer = 0
for i in range(1, N + 1):
    answer += sum(dp[i])
    
print(answer % 10007)