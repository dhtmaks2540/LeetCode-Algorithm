"""
어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지가 나올 수 있는지 구하라
A = 1, B = 2, ..., Z = 26에 해당

코드를 DFS 코드로 구현도 못했고 점화식도 떠올리지 못했다..

https://jyeonnyang2.tistory.com/55

알파벳은 26자리 이므로 A:1 부터 Z:26 까지의 숫자를 가질 수 있다. 즉 1 ~ 26 범위의 숫자만 알파벳으로
치환이 가능하다. 다만 한자리수 0은 해독할 수 없으므로 10이나 20만 알파벳으로 처리 가능

n = 25114 같은 숫자가 주어진다면 1번 인덱스 '2'부터 차례로 몇 개의 암호 가짓수를 가지는지 게산하면 된다.

방법은 아래와 같다.

1) 현재 자리숫자가 0보다 클 때 -> 이전 dp값을 더한다(이전 dp가 가지는 방법들 뒤에 한 자리수로 추가
하기만 하면 되므로 이전 dp 값을 default로 가질 수 있다.)
예) 2 5 1 1 4 에서 2 5 1 1까지는 이미 구했다고 하면 2 5 1 1 / 25 1 1 / 2 5 11 / 25 11 이렇게 4가지의
방법 뒤에 4를 독립적으로(한자리수로 생각)붙힐 수 있으므로 4가지를 더할 수 있다.

2) 이전 자리수와 현재 자리수를 두 자리숫자로 볼 때 10 ~ 26 사이의 숫자에 해당할 때 -> 전전 dp값을 더한다.
예) 2 5 1 1 4에서 2 5 1 까지의 방법 -> 2 5 1 / 25 1 에다가 독립적으로 14를 붙힐 수 있으므로
2가지를 더할 수 있다.

이렇게 두 가지 조건을 달아서 풀이하면 된다.

따라서 점화식은 이전 경우의 수 + 이전 자리수와 현재 자리수가 정상 범위(0이상 26이하)라면
전전 경우의 수를 더하는 식이된다. 해당 문제는 조건을 분기하며 점화식을
작성하는 것이 중요한 포인트인것 같다
"""

# 암호
n = list(map(int, input()))
l = len(n)
# 암호의 개수에 따른 경우의 수
dp = [0] * (l + 1)

# 앞에 숫자가 0이라면 0 출력
if n[0] == 0:
    print("0")
    exit()

n = [0] + n
# 0과 1은 1로 초기화
dp[0] = dp[1] = 1

for i in range(2, l + 1):
    # 현재 자리 숫자가 0보다 크다면
    if n[i] > 0:
        dp[i] += dp[i - 1]
    # 이전 자리수와 현재 자리수를 두 자리숫자로 볼 때 정상범위라면
    temp = n[i - 1] * 10 + n[i]
    if temp >= 10 and temp <= 26:
        dp[i] += dp[i - 2]
        
print(dp[l] % 1000000)