"""
주어지는 좌표의 합을 구해 출력하라

https://subbak2.tistory.com/65

표의 최대 크기가 1,024이고 합을 구해야 하는 횟수가 최대 100,000이므로 좌표가 주어질 때마다 
합을 계산하면 주어진 시간안에 절대 풀이할 수 없다. 따라서 표는 한번 주어지고 좌표만 달라지므로
미리 합을 계산하여 주어지는 좌표를 사용해 정답을 출력해야 한다. 이는 구간합 또는 다이나믹
프로그래밍을 통해 풀이할 수 있는데 아래의 해답은 다이나믹 프로그래밍을 통해 풀이한 방법이다.

우선 dp 테이블을 2차원 리스트로 선언한 후, dp[i][j] = (i, j) 좌표까지의 누적합 값으로 넣어준다.
dp[i - 1][j](위쪽) + dp[i][j - 1](왼쪽)을 더해주면 dp[i - 1][j - 1](대각선)이 중복되서
한번 들어가므로 이 값을 빼주며 현재 (i,j) 좌표의 값을 더해주면 된다. 즉, 점화식은
현재까지 누적된 위쪽의 합 + 현재까지 누적된 왼쪽의 합 - 현재까지 누적된 대각선의 합 + 현재 좌표의 값
으로 dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + graph[i][j]이다.
그림을 그려보면 훨씬 이해하기 쉽다. 그리고 이제 주어진 좌표를 구해야 하는데 주어진 좌표
x1, y1 - x2, y2에 대해서 합을 구하려면 dp[x2][y2] - dp[x2][y1 - 1] - dp[x1 - 1][y2] + dp[x - 1][y - 1]
을 해주면 된다. 이 또한 그림을 그려보며 이해하면 쉽다.

현재 문제를 다이나믹 프로그래밍으로 풀이할 수 있는 이유는 최적 부분 구조의 문제이며 하위 문제의 정답이
계속해서 중복되서 나오기 때문이다. 따라서 그림을 그려보며 점화식을 잘 세우는 것이 가장 중요하다.
"""


# DP를 사용하여 풀이
def solution1():
    import sys

    # 표의 크기, 합 횟수
    N, M = map(int, sys.stdin.readline().strip().split(" "))

    # 지도 입력
    graph = []
    for _ in range(N):
        graph.append(list(map(int, sys.stdin.readline().strip().split(" "))))
    
    # DP 배열
    dp = [[0] * (N + 1) for _ in range(N + 1)]
    
    # 점화식: dp[i][j] = (1,1)에서 (i,j) 까지의 합
    for i in range(1, N + 1):
        for j in range(1, N + 1):
            # 왼쪽 값 + 위에 값 - 중복되는 대각선 값 + 현재 값
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + graph[i - 1][j - 1]
          
    # 정답 출력
    for i in range(M):
        x1, y1, x2, y2 = map(int, sys.stdin.readline().strip().split(" "))
        print(dp[x2][y2] - dp[x2][y1 - 1] - dp[x1 - 1][y2] + dp[x1 - 1][y1 - 1])
        
solution1()