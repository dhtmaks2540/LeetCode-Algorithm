"""
A를 B번 곱한 수를 C로 나눈 나머지를 구하라

A와 B가 최대 2^31 - 1의 값으로 직접 곱하고 나머지를 구하려고 한다면 절대 시간안에 풀이할 수 없다.
따라서 규칙을 찾아보려고 했다. 규칙을 찾아보니 (A^B) % C = (A % C * B % C) % C라는 모듈러
공식이 있다는 것을 알았고 이를 사용해서 일정한 규칙을 찾은 후, 곱해야 하는 경우의 수에 규칙의 
개수를 나누면 문제를 풀이할 수 있겠다 생각했는데 규칙을 도출하는 코드를 구현해내지 못했다... 

https://st-lab.tistory.com/237

해당 문제에서는 지수 법칙과 모듈러 성질을 사용하여 풀이할 수 있다.

지수 법칙
a^(n + m) = a^n * a^m

모듈러 성질
(a * b) mod c = (a mod c * b mod c) * mod c

우선 모듈러 성질은 무시하고 지수 법칙을 생각해보자. 예시로 주어진 10^11을 생각해보면 이 둘을 반으로
나누는 것이다. 즉, 10^5 * 10^5 에다가 홀 수이므로 10을 따로 곱해서 10^5 * 10^5 * 10이 되는 것이다.
여기서 우리는 10^5에다가 제곱만 하고 10을 따로 곱하면 되기에 뒤의 10^5은 탐색할 필요가 없다. 즉,
n이라는 시간 복잡도가 logn으로 변경되는 것이다.

이제 모듈러 연산을 생각해야 하는데 return 되는 값에서 C로 나눈 나머지를 반환하면 정답이 되지만
이는 주어진 숫자가 Long형 범위를 훨씬 넘어설 수 있다. 그 이유는 밑과 지수가 최대라고 한다면 2^63 -1의
범위를 훨씬 벗어나기 때문이다. 따라서 위에서 본 모듈러 성질을 사용해서 범위를 좁혀야 한다.

(temp * temp * A) % C = ((temp * temp % C) * (A % C)) % C
					  = (((temp * temp % C) % C) * (A % C)) % C 	// (temp * temp % C) = (temp * temp % C) % C
					  = ((temp * temp % C) * A) % C
       
문제의 핵심 포인트는 분할 정복을 통해 문제를 최대한 작게 만든 후, 더 이상 분해할 수 없을 때부터 정복을
시작하며 정답을 도출하는 것이다. 이 문제 또한 브루트 포스로 진행했으면 절대 시간안에 풀이할 수 없다.
하지만 반 씩 쪼개어 나누면 O(N)이였던 시간 복잡도가 O(logN)으로 줄어들게 되어 문제를 풀이할 수 있게 된다.
따라서 분할 정복을 만나면 커다란 예시를 어떻게 쪼갤 것인지(분할) 생각한 후, 이들을 사용해 어떻게
정답을 도출할 지(정복) 생각 및 조합해서 정답을 도출해야 한다.
"""

import sys

A, B, C = map(int, sys.stdin.readline().strip().split(" "))

# a = 밑, exponent = 지수
def pow(a, exponent):
    # 지수가 1일 경우 A^1이므로 A를 그대로 반환
    if exponent == 1:
        return a % C
    
    # 지수의 절반에 해당하는 A^(exponent / 2) -> 분할
    temp = pow(a, exponent // 2)
    
    # 현재 지수가 홀 수 였다면 A^(exponent / 2) * A^(exponent / 2) * A 이므로
    # A를 한번 더 곱합
    # ex) A^9 = A^4 * A^4 * A
    # 정복
    if exponent % 2 == 1:
        return temp * temp * A % C
    
    # 그 외는 짝수이므로 제곱을 하여 반환
    # 정복
    return temp * temp % C

print(pow(A, B))