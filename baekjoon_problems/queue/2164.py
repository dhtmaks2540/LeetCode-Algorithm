"""
N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하라.

문제를 보면 한 장이 남을 때까지 아래와 같은 연산을 반복하라고 나와있다.
1. 제일 위에 있는 카드를 버린다
2. 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.

이는 큐를 사용하면 쉽게 구현할 수 있는 연산으로 큐는 선입선출의 특징을 가지므로 
첫 번째 연산은 제일 위에 있는(= 제일 앞에 있는)으로 해석하고 poll을 사용하면 O(1)의 시간 복잡도
두 번째 연산은 제일 위에 있는(= 제일 앞에 있는)으로 해석하고 poll을 사용한 후 그 원소를 제일 아래이
있는(= 제일 뒤에 있는)으로 해석하고 push를 사용하면 O(2)의 시간복잡도로 위의 연산을 구현할 수 있다.
따라서 최대 N이 주어지면 N - 1번동안 O(3)의 연산을 수행하므로 총 시간 복잡도는 O(3 * (N - 1))이므로
최종적으로 O(N)의 시간복잡도를 사용하여 문제를 풀이할 수 있다.

문제에서 주어진 연산을 원하는 시간 제한안에 풀어야 하므로 빠른 연산을 가지고 수행할 수 있는지 묻는
문제로 큐의 개념과 큐를 구현하는 라이브러리를 사용할 수 있는지 묻는 문제인듯하다. 항상 큐와 스택은
선입선출, 후입선출 등의 특징을 사용해서 O(1)의 시간복잡도를 가지고 원소를 pop, push 할 수 있기에
이를 어떻게 응용하면 좋은지 떠올리면 좋다!
"""

import sys
from collections import deque

# 정수
N = int(sys.stdin.readline().strip())
# 큐의 역할을 수행하는 Deque
queue = deque()

# 숫자 삽입
for i in range(1, N + 1):
    queue.append(i)
    
# 카드가 한 장 남을때까지 연산 수행
while len(queue) != 1:
    # 제일 위의 카드 한 장 제거
    queue.popleft()
    # 제일 위의 카드 한 장 아래로 옮기기
    queue.append(queue.popleft())
    
print(queue.popleft())