"""
N * N 인 배열 A를 만들고, 이 수들을 일차원 배열에 넣고 오름차순 정렬했을 때 B[K]을 구해라.

N의 최댓값은 10^5으로 직접 모든 값을 대입한다고 하면 여기서만 시간 복잡도가 10^5 * 10^5이 된다.
따라서 직접 모든 값을 대입한 후 정렬하여 풀이할 수는 없다. 

https://st-lab.tistory.com/281

4 * 4인 배열을 만든 후, B배열로 만들게 되면 1 2 2 3 3 4 4 4 6 6 8 8 9 12 12 16이라는 값이 나온다. 
이때, B배열의 11번째 값은 8이 된다. 여기서 B[11] = 8이라는 것은 8이라는 값보다 작거나 같은 
원소의 개수는 최소 11개라는 의미가 된다. 앞과 같은 논리의 이유는 B 행렬은 이미 오름차순으로 정렬되어
있기 때문이다.

위의 논리를 사용해서 우리는 B[K] = X에서 K가 주어지고 X를 찾아야 하기에 X값을 조정하면서 X보다 작거나
같은 원소의 개수를 합해 K값이랑 일치하는지 비교할 수 있다. 2차원 배열에서 A[i][j] = i * j라고 했기에
2차원 배열은 결국 구구단을 가지게 된다. 따라서 직접 행렬을 생성할 필요 없이 현재 단(1단, 2단 등)에서
X 값보다 작거나 같은 원소들의 합을 더해서 K와 비교해주는 방식으로 나아갈 수 있다. 다만, 직접 계산하면
시간 복잡도가 좋지 않기에 X / n 단의 몫이 X보다 작거나 같은 수의 값이 된다는 것을 알아야 한다.
이는 곱의 성질을 이용하는 것인데, 예를 들어 8이라는 값이 X라고 해보자.
그러면 1단에서는 8 / 1 = 8로, 8보다 작거나 같은 수의 개수는 8개가 된다.
2단에서는 8 / 2 = 4로, 8보다 작거나 같은 수의 개수는 4개가 된다.
3단에서는 8 / 3 = 3로, 8보다 작거나 같은 수의 개수는 2개가 된다.
이와 같은 이유는 결국 그 단을 단계적으로 누적하기 때문이다.

이제 정리해보면 다음과 같다. B[K] = X에서 우리는 K만 주어지기 때문에 X를 조정하면서 탐색해야 하는 것이다.
즉, X를 통해서 X보다 작은 원소의 개수(=K)를 찾고, 해당 값이 문제에서 주어지는 K값과 일치하는지를 이분탐색으로
구현하면 되는 것이다.

현재 문제는 우선 직접 탐색을 수행할 수 없는 문제이기에 브루트 포스와 같은 방법은 바로 패스해야 한다.
그리고 총 10^5 * 10^5이라는 수를 탐색하기 위해서는 O(logN)이라는 시간복잡도를 가지는 방법으로 
풀이해야 하기에 이분 탐색을 떠올릴 수 있다. 이제 이분 탐색을 적용하기 위해서 탐색해야 하는 값을 찾아야
하는데 우리는 K(인덱스)가 주어지고 그 값을 찾는 것이기에 값을 조정해나가면서 K가 맞는지 비교하는 방식으로
접근해야 한다는 사실을 알 수 있다. 여기서 이제 규칙을 찾아 위와 같은 방식으로 풀이해야한다.
접근하기 어려운 문제인것같다. 일단 수가 많이 주어지고 정렬했다와 같은 말이 문제에 있으면 이분 탐색을
떠올리고 조정해나가야 하는 수와 우리가 찾아야 하는 수를 두고 어떻게 이를 이분 탐색 식으로 구현할지
생각해야 하는 것이 중요한듯하다. 
"""

import sys

# 배열의 크기
N = int(sys.stdin.readline().strip())
# 찾으려는 인덱스
K = int(sys.stdin.readline().strip())

# 찾고자 하는 X는 left <= x <= right의 범위를 갖는다
left = 1
right = K

# lower bound(찾고자 하는 값과 같거나 큰 수가 있는 첫 번째 인덱스) -> 중복된 값이 있기에 사용
while left < right:
    mid = left + (right - left) // 2
    count = 0
    
    # 임의의 x에 대해 i번 째 행을 나눔으로써 x보다 작거나 같은 원소의 개수 누적 합을 구함
    # 다만, 각 행의 원소의 개수가 N을 초과하지 않는 선에서 합(최적화)
    for i in range(1, N + 1):
        count += min(mid // i, N)
        
    # count가 많다는 것은 임의의 x(mid)보다 작은 수가 B[K]보다 많다는 뜻
    if K <= count:
        right = mid
    else:
        left = mid + 1
        
print(left)